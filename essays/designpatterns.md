 
 
 
	Before I ever wrote a line of code, or even opened up a terminal on a computer, I was a combat medic with a scout-sniper platoon.  As you might guess, the two worlds are pretty far apart in terms of the actual work being done.  No mistake, the career change was entirely by design.  Medicine was interesting, but there was a lot about the profession I could easily do without in my life.  Software engineering is a welcome change of pace; and - no complaints here - I haven’t really come across too many areas where the two worlds diverge; except again, when design is involved.  Software engineers utilize “design patterns;” which are a means to guide “best-practices” within the software development community.  Their goal being not only to aid the development of modular code, but also to standardize its methodology.  An added benefit being of course that new coders may make use of design patterns to improve their own code by bringing it in line with community standards.  So what does that have to to with the military?  Well, it may not be huge surprise that the Army does the exact same thing with mission operations.  They simply use different terms - like “Standard Operating Procedures” or “Military Decision Making Processes”.  Maybe the words “design” and “pattern” just don’t carry the gravitas the military desires;  or maybe the Army has been doing it longer, I honestly couldn’t claim to know.  The point is, the general principle in mission planning is the same as in software design, and the Army breaks it down into seven basic phases: encounter a problem, analyze the problem, strategize a solution to the problem, analyze the strategy, compare the strategy to other known strategies, select the best strategy for the situation, try to implement that strategy.  Notice the word “strategy” here could be replaced with the word “design,” and all of a sudden we’re talking like project managers at a software firm.  Like in software engineering, each phase of mission planning has its own specific way of being solved according to the given mission; known “best-practices”, or historically successful strategies, for the given situation are considered accordingly.  Then there is implementation - regardless of how good a plan is, implementation is a matter that will likely face unique challenges; and for that reason, similar to a design plan, a strategy is just a template based on what is known to have worked previously.  It usually represents a best case scenario, with contingencies that would account for predictable high-risk situations and general mission disruption - things that result from poor intel or unwelcome surprises.  It can also be applied broadly; say the platoon that was intended to carry out the mission got assigned to another op with a higher priority, or the helicopter that was supposed to transport them had to be rerouted, just send the template to the next available platoon or helicopter and they’ll work out the details per their specific case.  And like with any app, larger scale military operations often have several moving parts.  Sometimes those parts are meant to pair or split up, other times one part waits to move until another part has accomplished a given task, some are simply on standby - just in case one part of the plan runs into complications.  Just like with design planning and coding as part of a team, mission planning synchronizes all the moving parts so that each individual component can function autonomously, thus minimizing the need for on-the-spot corrections from the command element (management).  In either case, actually executing whatever plans are set in place would be undeniably less efficient without integrating tried and true methodologies as a starting point. 
 
 
 
Software engineers utilize dozens of design patterns, many of which a student learning software design in a formal environment - such as myself - learns from day one.  Now, I’m not going to sit here and prattle off a list of all the well-recognized design patterns I have utilized throughout my school career.  I honestly couldn’t do that to you, not only because that would be incredibly boring, but also because I truly could not name all the officially recognized and most utilized design patterns I have used.  As mentioned, there are at least a couple dozen, and just as a matter of course I have probably used over half of them at one point or another; others I have seen utilized; and others still I have no understanding of at all.  That I use any is one of the benefits to well-recognized “best-practices,” they’re tried and true, so we use them as a basis for learning.  Which makes sense, software development is an ability that only comes with lots of hours spent applying the knowledge; I can’t think of one good reason to spend time developing “less-than-best practices” - I certainly do not doubt that these design patterns work.  This isn’t to say one-size fits all.   Most times, no template will fit perfectly, and so some creative problem solving will be needed.  It cannot be said enough that “design planning” is a tentative process that provides a template from which to base development and nothing is made permanent by a design plan.  Having had several design patterns ingrained into my coding style as part of my education is undoubtedly a benefit that has helped me code in a more succinct and understandable fashion.  As it is, some degree of familiarity with design patterns is essential for any would-be developer; but if that developer is also looking for pay, knowing design patterns will go a long way toward assuring an engineering firm that the code is worth the buck.
 

